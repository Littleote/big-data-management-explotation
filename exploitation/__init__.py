import importlib
from pathlib import Path
from enum import Enum

import duckdb
from pyspark.sql import SparkSession

from utils import Logger

ZONE = "exploitation"

STATUS = Enum("Status", ["FAILED_UPDATE", "SUCCESS"])


def extract(*pipes: str):
    """Run pipelines (by default all defined pipelines) from formatted to exploitation"""
    spark: SparkSession = SparkSession.builder.getOrCreate()
    spark.sparkContext.setLogLevel("ERROR")
    formatted = Path("formatted").absolute()
    exploitation = Path(ZONE).absolute()
    log = Logger(exploitation)
    status = {}
    for action in log.get_log():
        pipe, prefixed_status, *data = action.split(",")
        status[pipe] = (STATUS[prefixed_status.split(".", 1)[1]], data)
    if len(pipes) == 0:
        pipes = [
            dir_.stem
            for dir_ in exploitation.iterdir()
            if dir_.is_dir() and (dir_ / "pipeline.py").exists()
        ]
    with log.get_log_file() as log_file:
        for pipe in pipes:
            try:
                pipeline = importlib.import_module(f"{ZONE}.{pipe}.pipeline")
                print(f"Excecuting {pipe}'s pipeline...")
                extraction = pipeline.extract(spark, formatted, exploitation)
                if extraction is None:
                    print(f"{pipe}'s table already uses the latest commit")
                    extraction = (
                        status[pipe][1][0]
                        if status[pipe][0] == STATUS.FAILED_UPDATE
                        else None
                    )
                if extraction is not None:
                    print(f"Updating {pipe}'s table...")
                    try:
                        with duckdb.connect(f"{ZONE}/data.db") as conn:
                            conn.sql(
                                f"CREATE OR REPLACE TABLE {pipe} AS \
                                    SELECT * \
                                    FROM read_parquet('{ZONE}/{pipe}/{extraction}/*.parquet');"
                            )
                        print(f"Updated {pipe}'s table to match latest commit")
                        print(pipe, STATUS.SUCCESS, sep=",", file=log_file)
                    except Exception as err:
                        print(f"Failed to update {pipe}'s table due to: {err}")
                        print(
                            pipe,
                            STATUS.FAILED_UPDATE,
                            extraction,
                            sep=",",
                            file=log_file,
                        )
            except ModuleNotFoundError:
                print(f"Failed to load {pipe}'s pipeline")
            except Exception as err:
                print(f"Failed to run pipeline {pipe} due to: {err}")


def reset(*pipes: str):
    """Reset pipelines (by default all defined pipelines) in exploitation"""
    exploitation = Path(ZONE).absolute()
    if len(pipes) == 0:
        pipes = [
            dir_.stem
            for dir_ in exploitation.iterdir()
            if dir_.is_dir() and (dir_ / "pipeline.py").exists()
        ]
    for pipe in pipes:
        print("Reseting...")
        try:
            pipeline = importlib.import_module(f"{ZONE}.{pipe}.pipeline")
            pipeline.reset(exploitation)
            print(f"Reset pipeline {pipe}")
        except ModuleNotFoundError:
            print(f"Failed to load {pipe}'s pipeline")
        except Exception as e:
            print(f"Failed to reset pipeline {pipe} due to: {e}")
